## 동시성 제어란?

동시성 제어란, 서비스 운영 중 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 데이터 간섭 문제를 방지하고, 데이터의 일관성과 무결성을 유지하기 위한 관리 절차

이를 통해 다중 사용자 환경에서도 데이터베이스가 정확하고 안정적으로 작동할 수 있도록 보장

### 동시성 제어의 목적
- 트랜잭션 직렬화 보장: 트랜잭션이 순차적으로 실행된 것과 동일한 결과를 보장
- 데이터 일관성 유지: 동시에 실행되는 작업이 데이터의 무결성을 해치지 않도록 보호
- 경합 상태 방지: 여러 트랜잭션이 동일한 데이터를 동시에 수정하거나 읽으려 할 때 발생하는 문제 해결
- 응답성 및 공유도 향상: 다중 사용자 환경에서 자원을 효율적으로 활용


## 동시성 제어 기법

### 1. DB 락

**Pessimistic Lock (비관적 락)**
- 데이터 충돌이 많이 일어날 것으로 상황에 사용
- 데이터베이스의 동시성 문제를 해결하기 위해 S Lock과 X Lock을 사용하는 전략
- 데이터 충돌을 미리 방지하는 방식
- 트랜잭션이 데이터에 접근할 때 즉시 락을 획득, 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 함
- 예시: `select for update`를 이용하여 해당 행에 X Lock을 걸어 다른 트랜잭션이 접근하지 못하게 한다 (Mysql, PostgreSQL 기준)
- 주의: 불필요한 Lock에 따른 성능 저하 주의, 여러 테이블에 걸친 Lock 작업은 데드락 유발 가능성 내포


S-Lock
- `select .. from .. where .. for share`
- 동작 방식: 여러 트랜잭션이 S Lock 획득 → 다수의 트랜잭션이 동시에 읽지만 수정 불가


X-Lock
- `select .. from .. where .. for update`
- 한 번에 하나의 트랜잭션만 X Lock 획득 → 데이터를 읽거나 수정하는 동안 다른 트랜잭션은 접근 불가

**Optimistic Lock(낙관적 락)**
- 데이터 충돌이 적을 때 사용
- 데이터 충돌을 사후에 감지하여 처리하는 방식
- 트랜잭션이 데이터에 접근할 때 락을 사용하지 않고, 커밋 시점에 충돌 여부를 확인함
- 예시: 레코드에 버전 번호를 두고 업데이트 시 현재 버전과 비교하여 충돌을 감지하고 처리한다 (CAS 메커니즘)
- 주의: 잦은 경합으로 retry가 많아지면 DB Connection, 스레드 점유 등 잠재적 문제 요소 내포

### 2. 분산 락

분산 환경에서의 동기화 문제를 해결하기 위한 Lock 제어 기법으로 Redis와 같은 공용 저장소를 이용한 동시 제어 접근 메커니즘

#### Redis 분산락 순서

락과 트랜잭션은 데이터의 무결성을 보장하기 위해 아래 순서에 맞게 수행됨을 보장해야 한다.

> 락 획득 → 트랜잭션 시작 → 비즈니스 로직 수행 → 트랜잭션 종료 → 락 해제

**Lettuce**
- **특징**: Lettuce는 비동기적, 동기적, 리액티브 프로그래밍을 지원하는 Redis 클라이언트. 다양한 Redis 명령어를 직접적으로 사용할 수 있으며, 낮은 수준의 추상화를 제공
- **스핀락 구현**: Lettuce는 직접적인 분산 락 기능을 제공하지 않으며, 기본적으로 `SETNX`와 `EXPIRE` 명령어를 사용하여 애플리케이션 수준에서 Spin Lock을 구현해야 함
- **장점**: 높은 성능, 비동기적 지원, 리액티브 프로그래밍 지원
- **단점**: 분산 락 기능을 직접 구현해야 하는 부담

```java
while (!redisClient.setnx("lockKey", "lockValue")) {
    // 일정 시간 대기 후 재시도
    Thread.sleep(1000);
}
// 락을 획득한 후 작업 수행
try {
    // 임계 영역
} finally {
    redisClient.del("lockKey");
}
```

**Redisson**
- **특징**: Redisson은 Java 개발자를 위한 고수준의 추상화를 제공하며, 다양한 분산 객체, 컬렉션, 락, 동기화 기법을 지원
- **분산 락 구현**: Redisson은 `RLock` 클래스를 통해 분산 락을 쉽게 구현할 수 있으며, Pub/Sub 구조를 사용하여 락 획득 대기를 효율적으로 처리
- **장점**: 고수준의 추상화, 다양한 분산 객체 및 컬렉션 지원, 쉬운 분산 락 구현
- **단점**: 비교적 높은 메모리 사용량


```java
RLock lock = redissonClient.getLock("lockKey");
lock.lock();
try {
    // 임계 영역
} finally {
    lock.unlock();
}
```
## 동시성 이슈 발생 시나리오

1. 포인트 충전
```text
- 동시에 여러 사용자가 같은 계정에 포인트를 충전할 수 있다.
-  포인트 충전 요청의 경우 모두 성공해야 한다.
```

2. 좌석 예약
```text
- 동시에 사용자의 여러 요청이 존재할 수 있다.
- 동시성 문제 발생 시 하나의 결제 요청만 성공해야만 한다.
```

3. 결제
```text
- 동시에 사용자의 여러 요청이 존재할 수 있다.
- 동시성 문제 발생 시 하나의 결제 요청만 성공해야만 한다.
```

