## 목차
1. 캐시(Cache)를 왜 사용하는가?
2. 서버 캐시 종류
    1. 메모리 캐시 (로컬 캐시)
    2. 외부 캐시 (글로벌 캐시)
3. 캐시 전략 5가지
    1. 캐시 읽기 전략
        1. Look Aside 전략
        2. Read Through 전략
    2. 캐시 쓰기 전략
        1. Write Back 전략
        2. Write Through 전략
        3. Write Around 전략
    3. 캐시 읽기  + 쓰기 전략 조합
4. 캐시 스탬피드 현상

## 1. 캐시(Cache)를 왜 사용하는가?

#### 캐시란 무엇인가?
- 조회성능을 높이기 위해 사용
- 원본 보다 빠른 DB를 사용해서 조회 결과 값을 저장한 후 사용자에게 빠르게 응답을 내리기 위해 사용
- 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소
- 캐시는 저장공간이 작고 비싼만큼 빠른 성능을 제공한다.

#### 어떤 데이터를 캐시할건지?
- 반복적이고 동일한 결과를 돌려주는 경우(이미지, 썸네일)
- 자주 사용하는 상위 n%의 데이터
- 접근 시간이 오래 걸리는 데이터

#### 캐시 언제 만료를 시킬건지?
- 데이터 성격에 따라 다르다.(변경이 많이되냐에 따라서)
- 사용자한테 얼마나 실시간성 있게 변경이 보여야하는 데이터냐에 따라 다르다.

#### 캐시를 얼만큼 저장할건지?
- 리소스 여유분 만큼 저장

## 2. 서버 캐시 종류

### 1. 메모리 캐시 (로컬 캐시)
- caffine, ehcache

#### 메모리 캐시 특징

- 유저의 API 요청이 들어와서 cache hit 정보를 확인
    - cache miss가 뜨면 db를 조회한후 memory에 저장
- 저비용: 로컬 장비 내의 로컬 resource를 이용하기 때문에 별도의 네트워크 비용이 안든다.
- 신속성: Local에서만 작동하기 때문에 속도가 빠르다.
- 메모리 부족: 활성화된 애플리케이션 인스턴스에 데이터를 올려 캐싱하는 방법이므로 메모리 부족으로 인해 비정상 적인 종료가 발생 할 수 있다.
- 휘발성: 애플리케이션 종료될때, 캐시 데이터 사라짐
- 분산환경문제: 다른 서버와 데이터 공유가 어렵다.
    - 분산환경에서 메모리 캐시 동기화 문제로 인해 다른 데이터가 출력 될 수 있다.
    - 해결방법: 별도의 캐시 스토리지를 두고 모든 인스턴스가 하나의 관리 주체를 통해 제공받을 수 있도록 구성 (redis → 저장/삭제 될때마다 메모리 캐시 변경 작업)

### 2. 외부 캐시 (글로벌 캐시)
- redis

#### 외부 캐시서비스 특징

- 일관성: 별도의 외부 서비스를 두어서 분산된 환경에서도 동일한 캐시 기능을 제공
- 안정성: 외부 캐시 서비스의 Disk에 스냅샷을 저장하여 장애 발생 시 복구 용이
- 고가용성: 각 인스턴스에 의존하지 않으므로 분산 환경을 위한 HA 구성이 용이함
- 고비용성: 네트워크 통신을 통해 외부의 캐시 서비스와 소통해야 하므로 네트워크 비용 고려해야한다.

## 3. 캐시 전략 5가지

### 캐시 읽기 전략
#### 1. **Look Aside 전략 (cache Aside)**
- 데이터를 찾을 때 우선 캐시에 저장된 데이터가 있는지 찾는 전략 (***일반적으로 많이 사용하는 전략***)
    - 저장된 데이터가 없으면 DB에서 조회
- 반복적인 읽기가 많은 호출에 적합
- 캐시와 DB가 분리되어 원하는 데이터만 별도로 구성하여 캐시에 저장
- 캐시와 DB가 분리되어 캐시 장애 대비 구성이 되어있다.
    - redis가 다운 되더라도 DB에서 데이터를 가져올수 있어서 서비스 자체는 문제가 없음
    - 하지만, 캐시에 붙어있던 connection이 많았다면, redis가 다운된 순간 순간적으로 DB로 몰려서 부하 발생한다.

##### 읽기 순서
- Cache Hit (캐시 조회) → Cache Miss(조회 실패시) → DB 조회

#### 2. **Read Through 전략**
- 캐시에서만 데이터를 읽는 전략
- 데이터 동기화를 라이브러리나 캐시 제공자에게 위임 하는 방식)
- 데이터 조회하는데 속도가 전체적으로 느림
- 데이터 조회를 전적으로 redis에 의지하기 때문에 다운되면 서비스 이용에 차질이 생긴다.
- DB와 데이터 동기화가 항상 이루어져 데이터 정합성 문제를 벗어날 수 있다.
- 읽기가 많은 워크 로드에 적합

##### 읽기 순서
- Cache Hit(캐시 조회) → Cache Miss(DB에서 조회 후 캐시 처리) → 캐시 조회
- 데이터베이스의 접근을 최소화 하는 방식(다만 redis에 의존이 크기 때문에 다운되면 서비스 차질)

### 캐시 쓰기 전략
#### 1. Write Back 전략
- write behind 패턴 이라고도 한다.
- 캐시와 db 동기화를 비동기하기 때문에 동기화 과정이 생략
- 데이터를 저장할때 DB에 바로 쿼리하지않고, 캐시에 모아서 일정 주기 배치 작업을 통해 DB에 반영
- 캐시에 모아놨다가 DB에 쓰기 때문에 ***쓰기 쿼리 회수 비용***과 부하를 줄일 수 있음
- Write가 빈번하면서 Read를 하는데 많은 양의 Resource가 소모되는 서비스에 적합
- 데이터 정합성 확보

##### 읽기 순서
- 모든 데이터를 cache에 저장하고 일정 시간 뒤에 db에 저장한다.
- 캐시에 데이터를 모았다가 특정 시점마다 DB에 저장하는 방식

#### 2. Write Through 전략
- 데이터 베이스와 redis에 동시에 저장하는 전략
- 먼저 캐시에 저장하고 그다음 바로 DB에 저장한다.
- Read Through 와 마찬가지로 DB 동기화 작업을 캐시에 위임
- 데이터가 유실되면 안되는 상황에 적합
- 매 요청마다 두번의 write가 발생하기 때문에 성능 이슈 발생
- 항상 데이터가 최신으로 동기화 된다는 장점이 있다.
    - 하지만 저장을 2단계 과정을 거치기 때문에 상대적으로 느리다.

#### 3. Write Around 전략
- Write Through 보다 빠름
- ***모든 데이터를 DB에 저장***
- cache miss가 발생하는 경우에만 DB와 캐시에도 데이터를 저장
- 따라서 데이터의 불일치가 발생할 수 있다.


### 3. 캐시 읽기  + 쓰기 전략 조합

#### 1. look Aside + Write Around
- 가장 일반적으로 사용하는 조합
- 캐시 조회 → 캐시 미스 → 캐시에 데이터 저장

#### 2. Read Through + Write Around
- 항상 DB에 쓰고(Write Around), 캐시에서 읽을 때(Read Through) DB에서 데이터를 먼저 읽어오기 때문에 데이터 정합성 이슈에 대한 완벽한 대응가능

#### 3. Read Through + Write Through (데이터 베이스와 redis에 동시에 저장)
- 데이터를 쓸때 항상 캐시에 먼저 쓰므로, 읽어 올때 최신 캐시 데이터 보장
- 데이터를 쓸때 항상 캐시에서 DB로 보내므로, 데이터 정합성 보장

## 4. 캐시 스탬피드 현상
- 여러 어플리케이션이 동시에 키가 만료되어서 DB에 과부하가 오는 현상
- TTL 값을 너무 적게 설정할 시에 Look-aside 패턴에서 redis Cache miss 받은 서버가 직접 DB로 데이터 요청한 뒤, 다시 redis에 저장하는 과정을 거치기 때문에 캐시 스탬피드 현상이 발생할 수 있다.

### 해결방안
- Jitter(캐시 만료 시간에 0~10초 사이의 무작위 지연 시간을 추가하여 설정)
- caffeine Cache refresh 설정

